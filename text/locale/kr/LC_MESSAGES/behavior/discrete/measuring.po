#
msgid ""
msgstr ""
"Project-Id-Version: Modelica by Example v0.3.6\n"
"Report-Msgid-Bugs-To: mail@modelica.co.kr\n"
"POT-Creation-Date: 2023-01-28 22:37+0000\n"
"PO-Revision-Date: 2023-03-12 22:37+0000\n"
"Last-Translator: Baek Youngjin, mail@modelica.co.kr / Ha HyeonSu, <iloveyou934671@gmail.com>\n"
"Language-Team: modelica.co.kr <mail@modelica.co.k>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"


#: ../../source/behavior/discrete/measuring.rst:5
msgid "Speed Measurement"
msgstr ""
"속도 측정(Speed Measurement)"

#: ../../source/behavior/discrete/measuring.rst:8
msgid "Baseline System"
msgstr ""
"베이스라인 시스템(Baseline System)"

#: ../../source/behavior/discrete/measuring.rst:10
msgid ""
"There are many applications where we need to model the interaction "
"between continuous behavior and discrete behavior.  For this section, "
"we'll look at techniques used to measure the speed of a rotating shaft.  "
"For our discussion here, we will reuse the :ref:`mechanical example "
"<mech-example>` we discussed previously in our discussion of :ref:`basic-"
"equations`:"
msgstr ""
"연속 동작과 불연속 동작 간의 상호 작용을 모델링해야 하는 많은 응용 프로그램이 있습니다. "
"이 섹션에서는 회전 샤프트의 속도를 측정하는 데 사용하는 기술을 살펴보겠습니다. "
"이전에 기본 방정식에 대해 논의한 :ref:`기계 예제 <mech-example>` 를 재사용할 것입니다."


#: ../../source/behavior/discrete/measuring.rst:23
msgid ""
"We will reuse this model by adding an ``extends`` clause to our model.  "
"This essentially imports everything from the model we are extending from."
"  We'll talk more about the ``extends`` clause later when we discuss "
":ref:`packages`.  For now, just think of it as copying the contents of "
"another model into the current model."
msgstr ""
"모델에 ``extends`` 절을 추가하여 이 모델을 재사용 함으로써,  "
"본질적으로 확장하려고 하고 있는 모델에서 모든 것을 가져옵니다. "
"``extends`` 절에 대해서는 나중에 :ref:`packages` 에 대해 논의할 때 더 자세히 이야기하겠습니다. "
"지금은 다른 모델의 내용을 현재 모델에 복사하는 것으로 생각하십시오."



#: ../../source/behavior/discrete/measuring.rst:29
msgid "Recall the solution for the ``SecondOrderSystem`` model looks like this:"
msgstr ""
"``SecondOrderSystem`` 모델에 대한 해는 다음과 같습니다."

#: ../../source/behavior/discrete/measuring.rst:35
msgid ""
"In this case, we are simply plotting the solution that we computed. But "
"in a real system, we can't directly know the rotational velocity of a "
"shaft.  Instead, we have to measure it.  But measurement introduces error"
" and each measurement technique introduces different kinds of errors.  In"
" this section, we'll look at how we can model different kinds of "
"measurement techniques."
msgstr ""
"이 경우,  단순히  계산한 해를 선도로 표현 합니다. "
"그러나 실제 시스템에서는 샤프트의 회전 속도를 직접적으로 알 수 없으며, 대신 측정해야 합니다."
"측정은 오류를 발생시키고 각 측정 기술은 서로 다른 종류의 오차를 생성합니다. "
"이 섹션에서는 이와 관련한 다양한 종류의 측정 기술을 모델링하는 방법을 살펴보겠습니다."


#: ../../source/behavior/discrete/measuring.rst:45
msgid "Sample and Hold"
msgstr ""
"샘플과 홀드(Sample and Hold)"

#: ../../source/behavior/discrete/measuring.rst:47
msgid ""
"The first type of measurement we will examine is a sample and hold "
"approach to measurement.  Some speed sensors have circuits for measuring "
"the rotational speed of the system.  But instead of providing a "
"continuous value for the speed, they sample it at a given point in time "
"and then store it somewhere.  This is called \"sample and hold\".  The "
"following model demonstrates how to implement a sample and hold approach "
"to measuring the angular velocity ``omega1``:"
msgstr ""
"검토할, 첫 번째 유형은 측정에 대한 샘플 앤 홀드 접근 방식입니다. "
"일부 속도 센서에는 시스템의 회전 속도를 측정하는 회로가 있습니다. "
"그러나 속도에 대한 연속적인 값을 제공하는 대신, 주어진 시점에서 샘플링한 다음에 어딘가에 저장합니다."
"이를 "샘플 앤 홀드"라고 합니다."
"다음 모델은 각속도 ``omega1`` 측정에 대한 샘플 앤 홀드 접근 방식을 구현하는 방법을 보여줍니다."


#: ../../source/behavior/discrete/measuring.rst:61
msgid ""
"Note the presence of the ``discrete`` qualifier in the declaration of "
"``omega1_measured``.  This special qualifier indicates that the specified"
" variable does not have a continuous solution.  Instead, the value of "
"this variable will make (only) discrete jumps during the simulation.  It "
"is not required to include the ``discrete`` keyword but it is useful "
"because it provides additional information about the intent of the model "
"that the compiler can check (*e.g.,* making sure we never request the "
"derivative of that variable)."
msgstr ""
"``omega1_measured`` 선언에 ``discrete`` 한정자가 있습니다."
"이 특수 한정자는 지정된 변수에 연속 해가 없음을 나타냅니다."
"대신, 이 변수의 값은 시뮬레이션 중에 급격한 이산적인 변화(만)을 만듭니다. "
"``discrete`` 키워드를 포함할 필요는 없지만 컴파일러가 확인할 수 있는 모델의 의도에 대한 추가 정보를 제공하기 때문에 유용합니다(*예:* 해당 변수의 파생적인 결과물을 요청하지 않도록 함)."



#: ../../source/behavior/discrete/measuring.rst:70
msgid "Let us now examine the solution generated by this model:"
msgstr ""
"이제 이 모델에서 생성된 해를 살펴보겠습니다."

#: ../../source/behavior/discrete/measuring.rst:75
msgid ""
"The important thing to note in the solution is how the measured value is "
"piecewise-constant.  This is because the value of ``omega1_measured`` is "
"set only when the ``when`` statement becomes active.  The ``sample`` "
"function is a special built-in function that first becomes true at the "
"time indicated by the first argument (``0`` in this case) and then at "
"regular intervals after that.  The duration of these regular intervals is"
" indicated by the second argument (``sample_time`` in this case)."
msgstr ""
"해에서 주목해야 할 중요한 사항은, 측정된 값이 구간(조각난) 상수인지 여부입니다. "
"``omega1_measured`` 값은 ``when`` 문이 활성화될 때만 설정되기 때문입니다. "
"``sample`` 함수는 첫 번째 인수(이 경우 ``0``)에 의해 지정된 시간에 먼저 참이 되고,"
"그 이후 일정한 간격으로 참이 되는 특별한 내장 함수입니다."
"이러한 규칙적인 간격의 연속 시간에 대한 설정은 두 번째 인수(이 경우 ``sample_time``)로 표현 합니다."


#: ../../source/behavior/discrete/measuring.rst:87
msgid "Interval Measurement"
msgstr ""
"구간 측정(Interval Measurement)"

#: ../../source/behavior/discrete/measuring.rst:89
msgid ""
"In the previous example, we weren't actually making any estimates for the"
" speed, we were simply reporting the value of the variable ``omega1`` "
"only at specific times.  In other words, at the moment that we sampled "
"``omega1`` our sample was completely accurate.  But by \"holding\" our "
"measured value (instead of continuing to track ``omega1``), we introduced"
" some artifact in the measurement."
msgstr ""
"앞의 예제에서  실제로 속도를 추정하지 않고 단순히 특정 시간에만 변수 ``omega1`` 값을 전달 했습니다. "
"즉, ``omega1`` 을 샘플링한 순간의 값은 완전히 정확 한 것 입니다."
"다른말로 표현하면, 측정된 값을 그대로 "유지(hold)"함으로써(``omega1`` 을 계속 추적하는 대신) 측정에 약간의 인위적인 조작이 이루어졌을 뿐입니다."
 
#: ../../source/behavior/discrete/measuring.rst:96
msgid ""
"In the remaining examples, we will focus on techniques used to estimate "
"the speed of a rotating shaft.  In these cases, we will never make direct"
" use of the actual speed in our measurement.  Instead, we will respond to"
" events generated by the physical system and attempt to use these events "
"to reconstruct an estimate of the rotational speed."
msgstr ""
"나머지 예제에서는, 회전축의 속도를 추정하는 기술에 중점을 둘 것입니다. "
"이 경우, 측정 시 시뮬레이션에서 계산한 실제 속도를 직접 사용하지 않습니다. "
"대신 물리적 시스템에서 생성된 이벤트에 응답하고 이러한 이벤트를 사용하여 회전 속도의 추정치를 재구성하려고 시도합니다."


#: ../../source/behavior/discrete/measuring.rst:102
msgid ""
"The events that we will be responding to are generated by the discrete "
"elements attached to the spinning shaft.  For example, a typical way to "
"produce these events is to use a \"tooth wheel encoder\".  A tooth wheel "
"encoder includes a gear on the rotating shaft.  On either side of the "
"gear, we place a light source and a light sensor.  As the gear teeth pass"
" in front of the light source, they block the light.  The result is that "
"the signal from the light sensor will include an approximate square wave."
"  The leading edge of these square waves are the events we will be "
"responding to."
msgstr ""
"응답할 이벤트는 회전축에 부착된 개별 요소에 의해 생성됩니다. "
"예를 들어 이러한 이벤트를 생성하는 일반적인 방법은 "회전식 광학 엔코더(톱니 바퀴 모양으로 위치를 측정할 수 있는 구조의 인코더)"를 사용하는 것입니다. "
"톱니바퀴 엔코더에는 회전축에 기어가 포함되어 있습니다. 기어 양쪽에 광원과 광 센서를 배치합니다. "
"기어 이빨이 광원 앞을 지나갈 때 빛을 차단하게 되고, 그 결과 구형파 형태의 광 센서 신호를 생성합니다."
"이 구형파의 상승 엣지(rising edge, leading edge)에 이벤트로 반응합니다."


#: ../../source/behavior/discrete/measuring.rst:112
msgid ""
"The first estimation method we will examine computes the speed of the "
"shaft by measuring the time interval that passes between events. Knowing "
"that these events occur whenever the shaft has rotated by an angle of "
":math:`\\Delta\\theta`, we can estimate the speed as:"
msgstr ""
"검토할 첫 번째 추정 방법은 각 이벤트의 사이를 통과하는 시간 간격을 측정하여 샤프트의 속도를 계산 하는것 입니다."
"샤프트가 정해진 각도 :math:`\Delta\theta` 만큼 회전할 때마다 이벤트가 발생한다는 것을 알기 때문에 다음과 같이 속도를 추정할 수 있습니다."


#: ../../source/behavior/discrete/measuring.rst:117
msgid "\\hat{\\omega} = \\frac{\\Delta\\theta}{\\Delta t}"
msgstr ""

#: ../../source/behavior/discrete/measuring.rst:121
msgid "This technique for speed estimation can be represented in Modelica as:"
msgstr ""

#: ../../source/behavior/discrete/measuring.rst:127
msgid ""
"where ``tooth_angle`` represents :math:`\\Delta\\theta`.  Note how "
"``tooth_angle`` is not something the user needs to specify.  Instead, the"
" user specifies the number of teeth using the ``teeth`` parameter. The "
"``tooth_angle`` parameter is then computed using the value of ``teeth`` "
"(note that while we have hand coded the value of :math:`pi` here, we'll "
"learn how to avoid this later in the book when we talk about "
":ref:`constants`)."
msgstr ""
"여기서 ``tooth_angle`` 은 :math:`\Delta\theta` 를 나타냅니다. "
"``tooth_angle`` 은 사용자가 지정해야 하는 항목이 아니며,"
"대신 사용자는 ``teeth`` parameter를 사용하여 톱니의 이빨 수를 지정합니다. "
"``tooth_angle`` 파라미터는 ``teeth`` 값을 사용하여 계산 합니다. "
"(여기서는 :math:`pi` 값을 직접 작성하였는데, :ref:`constants` 에 대해 이야기할 때 다시 다루겠습니다.)"



#: ../../source/behavior/discrete/measuring.rst:135
msgid "Let's take a close look at the ``when`` statement in this model:"
msgstr ""
"이 모델의 ``when`` 문을 자세히 살펴보겠습니다."

#: ../../source/behavior/discrete/measuring.rst:141
msgid ""
"Here, we use the vector expression syntax used previously in the :ref"
":`bouncing-ball` example.  Recall that the ``when`` statement becomes "
"active if **any** of the conditions become true.  In this case, the "
"``when`` statement becomes active if the angle, ``phi1``, becomes greater"
" than ``next_phi`` or less than ``prev_phi``."
msgstr ""
"여기에서는 이전에 :ref:`bouncing-ball` 예제에서 사용된 벡터 표현식 구문을 사용합니다."
"조건 중 하나라도 참이면 ``when`` 문이 활성화된다는 점을 기억하십시오."
"이 경우 각도 ``phi1`` 이 ``next_phi`` 보다 크거나 ``prev_phi`` 보다 작으면 ``when`` 문이 활성화됩니다."


#: ../../source/behavior/discrete/measuring.rst:147
msgid ""
"Another thing to note is the use of the ``pre`` operator throughout the "
"``when`` statement.  When an event occurs in a model, there is a chance "
"that the value of some variables may change discontinuously. During an "
"event, while we are trying to resolve what values all the variables "
"should have as a result of the event, the ``pre`` operator allows us to "
"reference the value of a variable **prior** to the event. The ``pre`` "
"operator is used in this model to refer to the previous (pre-event) "
"values of ``next_phi``, ``prev_phi`` and ``last_time``. The ``pre`` "
"operator is necessary because all of these variables are affected by the "
"statements inside the ``when`` statement.  So, for example, ``last_time``"
" (without the ``pre`` operator) refers to the value of ``last_time`` at "
"the conclusion of the event while ``pre(last_time)`` refers to the value "
"of ``last_time`` prior to any event occurring."
msgstr ""
"주목해야 할 또 다른 사항은 ``when`` 문 안에서 ``pre`` 연산자를 사용한다는 것입니다. "
"모델에서 이벤트가 발생하면 일부 변수의 값이 불연속적으로 변할 가능성이 있습니다."
"이벤트의 결과로 모든 변수가 어떤 값을 가져야 하는지 확인하려고 시도할 때, ``pre`` 연산자를 사용하면 이벤트 **이전** 변수의 값을 참조할 수 있습니다. "
"``pre`` 연산자는 이 모델에서 ``next_phi`` , ``prev_phi`` 및 ``last_time`` 의 이전(먼저 발생한 이벤트) 값을 참조하는 데 사용합니다."
"``pre`` 연산자는 이러한 모든 변수가 ``when`` 문 내부의 구문에 의해 영향을 받습니다."
"예를 들어 ``last_time`` ( ``pre`` 연산자 없이)은 이벤트가 끝날 때 ``last_time`` 값을 참조하고 ``pre(last_time)`` 값은 이벤트가 발생하기 전의 ``last_time`` 을 참조하기 때문 입니다. "


msgid "Use of the ``pre`` operator"
msgstr ""
``pre`` 연산자 사용(Use of the ``pre`` operator)

#: ../../source/behavior/discrete/measuring.rst:164
msgid ""
"In general, if a variable changes as a result of a ``when`` statement "
"becoming active, you **almost always** want to use the ``pre`` operator "
"when referring to that variable in the conditional expression associated "
"with the ``when`` statement (as we have done in the previous example).  "
"This makes it clear that you are responding to what was happening before "
"the ``when`` statement was triggered."
msgstr ""
"일반적으로 ``when`` 문이 활성화되어 변수가 변경되면 **거의 항상** ``pre`` 연산자를 "
"사용하여 해당 변수와 관련된 ``when`` 문(이전 예제에서 했던 것처럼) 조건식을 참조합니다."
"이런 방식을 통해 ``when`` 문이 트리거되기 전에 발생한 일에 대해 응답하고 있음을 분명히 표현 합니다."


#: ../../source/behavior/discrete/measuring.rst:172
msgid "Let's take a look at the speed estimates provided by this approach:"
msgstr ""
"앞서 제시한 방식에서 추정하는 예상 속도를 보겠습니다."

#: ../../source/behavior/discrete/measuring.rst:177
msgid ""
"There are two important properties of this estimation algorithm that we "
"can immediately see in these results.  The first is that the estimate is "
"unsigned.  In other words, we cannot tell from a device like a tooth "
"wheel encoder which **direction** the shaft is rotating. Also, low speeds"
" and changes in rotational direction can degrade the accuracy of the "
"estimate significantly.  The results are also very sensitive the number "
"of teeth involved.  If we were to reduce the number of teeth used in our "
"encoder by setting ``teeth`` to 20, we'd get very different results."
msgstr ""
"결과에서 즉시 볼 수 있는, 이 추정 알고리즘의 두 가지 중요한 속성이 있습니다. "
"첫 번째는 추정치가 부호가 없다는 것입니다. "
"즉, 톱니바퀴 엔코더와 같은 장치에서는 축이 어느 **방향** 으로 회전하는지 알 수 없습니다."
"두번째는, 낮은 속도인 경우와 회전 방향이 변하는 경우에는 추정의 정확도를 크게 떨어뜨릴 수 있다는 것 입니다."
"결과 또한, 관련된 톱니의 수에 매우 민감합니다."
"``teeth`` 를 20으로 설정하여 인코더에 사용하는 톱니 수를 줄이면 매우 다른 결과를 얻게 됩니다."


#: ../../source/behavior/discrete/measuring.rst:190
msgid ""
"To understand exactly why the measured signal is so inaccurate, it helps "
"to consider the following plot which shows how the angle, ``phi1`` "
"compares to the angles associated with the adjacent teeth, ``next_phi`` "
"and ``prev_phi``."
msgstr ""
"측정된 신호가 왜 그렇게 부정확한지 정확히 이해하려면, 각도 ``phi1`` 에 따른 인접한 두 톱니의 각도인 ``next_phi`` 및  ``prev_phi`` 를 비교하는 다음 선도를 볼 필요가 있습니다."

#: ../../source/behavior/discrete/measuring.rst:198
msgid ""
"In this plot, we can clearly see how relatively low speeds and speed "
"reversals create irregular events that introduce significant estimation "
"error."
msgstr ""
"이 선도를 통해, 상대적으로 낮은 속도와 속도의 방향 전환이 상당한 추정에서의 오류를 유발하는 불규칙한 이벤트를 생성하는 것을 명확하게 볼 수 있습니다."

#: ../../source/behavior/discrete/measuring.rst:205
msgid "Pulse Counting"
msgstr ""
"펄스 카운팅(Pulse Counting)"

#: ../../source/behavior/discrete/measuring.rst:207
msgid ""
"The interval measuring technique mentioned above requires hardware that "
"can perform speed calculations on hardware interrupts.  Another approach "
"to estimating speed is the count how many events occur within a given "
"(fixed) time interval and use that as an estimate of speed. Using this "
"method, only the summation of events occurs when the events occur and the"
" calculations are deferred to a regularly scheduled update."
msgstr ""
"위에서 언급한 간격을 측정하는 기술에서는 물리적으로 발생하는 인터럽트에 대한 속도 계산을 수행할 수 있는 하드웨어가 필요합니다."
"속도를 추정하는 또 다른 접근 방식은 주어진(고정된) 타임 스탭 내에서 발생하는 이벤트 수를 세고 이를 속도 추정치로 사용하는 것입니다. "
"이 방법을 사용하면 이벤트가 발생할 때 이벤트 합계만 집계하고, 계산은 정기적으로 예정된 시점으로 업데이트를 미루어 둘 수 있습니다."


#: ../../source/behavior/discrete/measuring.rst:215
msgid ""
"Building on the previous examples in this section, the following seems "
"like a natural way to create a model that implements this estimation "
"technique:"
msgstr ""
"이 섹션의 이전 예제를 기반으로, 다음은 이 추정 기법을 구현하는 모델을 만드는 자연스러운 방법을 보여 주겠습니다."

#: ../../source/behavior/discrete/measuring.rst:224
msgid ""
"However, there is a problem in this model.  Note that there are actually "
"**two** equations for ``count``.  Trying to compile such a model will "
"lead to a situation where there are more equations than variables "
"(*i.e.,* the problem is singular)."
msgstr ""
"그러나 이 모델에는 ``count`` 에 대한 방정식이 **두 개** 있다는 문제점이 있습니다.  "
"이러한 모델을 컴파일하려고 하면 변수보다 방정식이 더 많은 상황이 발생합니다. *즉,* 문제가 특이(singular) 합니다."


#: ../../source/behavior/discrete/measuring.rst:229
msgid ""
"So what can we do about this?  We need two different equations because "
"the updates to ``count`` occur in response to different events.  We could"
" try to formulate everything under a single ``when`` statement, like "
"this:"
msgstr ""
"그래서  이러한 현상에 대해 어떻게 해결 할 수 있을까요? "
"``count`` 에 대한 업데이트가 서로 다른 이벤트에 대한 응답으로 발생하기 때문에 두 개의 서로 다른 방정식이 필요합니다. "
"그래서 다음과 같이 단일 ``when`` 문 아래 모든 것을 공식으로 표현 할 수 있습니다."


#: ../../source/behavior/discrete/measuring.rst:248
msgid ""
"But this kind of code quickly becomes hard to read.  Fortunately, we can "
"address this situation by placing all the ``when`` statements in an "
"``algorithm`` section."
msgstr ""
"하지만 이런 종류의 코드는 금방 읽기 어렵습니다."
"다행스럽게도  모든 ``when`` 문을 ``algorithm`` 섹션에 배치하여 이 상황을 해결할 수 있습니다."


#: ../../source/behavior/discrete/measuring.rst:252
msgid ""
"The nature of an ``algorithm`` section is that it is treated as one "
"single equation for any variables that are assigned within it.  This "
"allows multiple assignments to ``count``, for example.  When using an "
"``algorithm`` section, it is very important to understand that the "
"**order** of assignment becomes important.  If a conflict should arise "
"(*e.g.,* a variable is assigned two values within the same ``algorithm`` "
"section), the last one is the one that will be used.  Another thing to "
"note about ``algorithm`` sections is that you cannot write general "
"equations.  Instead, you must write *assignment statements*."
msgstr ""
"``algorithm`` 섹션의 특성은 그 안에 할당된 모든 변수에 대해 하나의 단일 방정식으로 취급 합니다."
"예를 들어 ``count`` 에 대한 다중 할당을 허용합니다. "
"그래서, ``algorithm`` 섹션을 사용할 때 할당의 **순서** 가 중요해진다는 것을 이해하는 것이 매우 중요합니다. "
"충돌이 발생하는 경우(*예:* 동일한 ``algorithm`` 섹션 내에서 변수에 두 개의 값이 할당되는 경우)는 마지막 값이 사용합니다. "
"``algorithm`` 섹션에 대해 주의해야 할 또 다른 사항은 일반 방정식을 작성할 수 없다는 것입니다. 그 대신 *대입문* 을 작성해야 합니다."

#: ../../source/behavior/discrete/measuring.rst:262
msgid ""
"In this way, an ``algorithm`` section is very much like the way most "
"programming languages work.  The statements in the algorithm section are "
"executed in order and each statement isn't interpreted as an equation, "
"but rather as an assignment of an expression to a variable. The "
"familiarity of assignment statements may make using ``algorithm`` "
"sections attractive to people with a programming background who find the "
"otherwise equation oriented aspects of Modelica disorienting and "
"unfamiliar.  But be aware that one big reason to avoid ``algorithm`` "
"sections is because they interfere with the symbolic manipulation "
"performed by the Modelica compiler.  This can result in both poor "
"simulation performance and a loss of flexibility in how you compose your "
"models.  So it is best to use an ``equation`` section whenever possible."
msgstr ""
"이런 식으로 ``algorithm`` 섹션은 대부분의 프로그래밍 언어가 작동하는 방식과 매우 유사합니다. "
"알고리즘 섹션의 명령문은 순서대로 실행되며 각 명령문은 방정식으로 해석되지 않고 변수에 표현식을 할당한 것으로 해석합니다. "
"모델리카의 방정식 지향적인 측면이 혼란스럽고 익숙하지 않은,"
"프로그래밍 배경을 가진 사람들에게 할당문의 친숙함은 ``algorithm`` 섹션을 매력적으로 느끼게 할 수 있습니다. "
"그러나 ``algorithm`` 섹션을 피해야 하는 한 가지 큰 이유는 모델리카 컴파일러가 수행하는 기호 조작을 방해하기 때문입니다."
"이로 인해 시뮬레이션 성능이 저하되고 모델 구성 방식의 유연성이 저하될 수 있습니다."
"따라서 가능할 때마다 ``equation`` 섹션을 사용하는 것이 가장 좋습니다."


#: ../../source/behavior/discrete/measuring.rst:276
msgid ""
"In our case, there are no significant consequences to using the "
"``algorithm`` section.  Here is an example of how the previous estimation"
" algorithm could be refactored using an ``algorithm`` section:"
msgstr ""
"이 경우는  ``algorithm`` 섹션을 사용해도 큰 결과의 변화는 없습니다. "
"다음은 ``algorithm`` 섹션을 사용하여 이전에 보인 추정 알고리즘을 리팩터링하는 방법의 예입니다."


#: ../../source/behavior/discrete/measuring.rst:285
msgid ""
"The simulated results of this estimation technique can be seen in the "
"following plot:"
msgstr ""
"이 추정 기법의 시뮬레이션 결과는 다음 선도에서 볼 수 있습니다."

#: ../../source/behavior/discrete/measuring.rst:291
msgid ""
"Again, we see that this approach cannot determine the direction of "
"rotation.  With the following plot, we can get a sense of how many events"
" occur within each sample interval:"
msgstr ""
"다시 말하지만 이 접근 방식은 회전 방향을 결정할 수 없습니다. "
"다음 선도를 통해 각 샘플 간격 내에서 발생하는 이벤트 수를 파악할 수 있습니다."


#: ../../source/behavior/discrete/measuring.rst:298
msgid ""
"In general, the higher the count gets in an interval, the more accurate "
"the estimate."
msgstr ""
"일반적으로 간격에서 카운트가 높을수록(저속일 수록) 추정치가 더 정확합니다."

#: ../../source/behavior/discrete/measuring.rst:302
msgid "Conclusion"
msgstr ""
"결론(Conclusion)"

#: ../../source/behavior/discrete/measuring.rst:304
msgid ""
"This section demonstrates how we can use the ``when`` construct to "
"respond to physical events that occur in our system.  These kinds of "
"events and the impact they have on our system are just as important as "
"the continuous dynamics we've covered previously.  The ability to capture"
" and respond to these physical events is an important part of why "
"Modelica is so well suited to model complete systems since those system "
"frequently include both continuous and discrete behavior."
msgstr ""
"이 섹션에서는 ``when`` 구성을 사용하여 시스템에서 발생하는 물리적 이벤트에 응답하는 방법을 보여줍니다."
"이러한 종류의 이벤트와 시스템에 미치는 영향은 이전에 다룬 연속  역학만큼이나 중요합니다."
"이러한 물리적 이벤트를 표현하고 이에 대응하는 기능은 모델리카가 전체 시스템을 모델링하는데 매우 적합한 중요한 이유중 하나 입니다."
"이러한 시스템에는 종종 연속 및 불연속 동작이 모두 포함되기 때문입니다."


#~ msgid ""
#~ "where ``tooth_angle`` represents "
#~ ":math:`\\Delta\\theta`.  Note how ``tooth_angle``"
#~ " is not something the user needs "
#~ "to specify.  Instead, the user species"
#~ " the number of teeth using the "
#~ "``teeth`` parameter. The ``tooth_angle`` "
#~ "parameter is then computed using the "
#~ "value of ``teeth`` (note that while "
#~ "we have hand coded the value of"
#~ " :math:`pi` here, we'll learn how to"
#~ " avoid this later in the book "
#~ "when we talk about :ref:`constants`)."
#~ msgstr ""

#~ msgid ""
#~ "In this way, an ``algorithm`` section"
#~ " is very much like the way most"
#~ " programming languages work.  The "
#~ "statements in the algorithm section are"
#~ " executed in order and each statement"
#~ " isn't interpreted as an equation, "
#~ "but rather as an assignment of an"
#~ " expression to a variable. The "
#~ "familiarity of assignment statements may "
#~ "make using ``algorithm`` sections attractive"
#~ " to people with a programming "
#~ "background who find the otherwise "
#~ "equation oriented aspects of Modelica "
#~ "disorienting and unfamiliar.  But be "
#~ "aware that one big reason to avoid"
#~ " ``algorithm`` sections is because they "
#~ "interfere with the symbolic manipulation "
#~ "performed by the Modelica compiler.  "
#~ "This can result in both poor "
#~ "simulation performance and a loss of "
#~ "flexibility in how you compose your "
#~ "models.  So it is best to use "
#~ "an ``equation`` section whenever possible"
#~ msgstr ""

#~ msgid "extends"
#~ msgstr ""

#~ msgid "discrete"
#~ msgstr ""

#~ msgid "algorithm section"
#~ msgstr ""

