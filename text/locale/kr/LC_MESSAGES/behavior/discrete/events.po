#
msgid ""
msgstr ""
"Project-Id-Version: Modelica by Example v0.3.6\n"
"Report-Msgid-Bugs-To: mail@modelica.co.kr\n"
"POT-Creation-Date: 2023-01-28 22:37+0000\n"
"PO-Revision-Date: 2023-03-12 22:37+0000\n"
"Last-Translator: Baek Youngjin, mail@modelica.co.kr / Ha HyeonSu, <iloveyou934671@gmail.com>\n"
"Language-Team: modelica.co.kr <mail@modelica.co.k>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"


#: ../../source/behavior/discrete/events.rst:4
msgid "Events"
msgstr ""
"이벤트(Events)"

#: ../../source/behavior/discrete/events.rst:8
msgid ""
"In the first chapter on :ref:`basic-equations` we saw examples of how to "
"describe continuous behavior.  The equations introduced in that chapter "
"applied at all times and the solutions to those equations were always "
"continuous.  In this chapter, we discussed the various ways in Modelica "
"to describe discrete behavior.  Events are the root cause of all discrete"
" behavior in Modelica."
msgstr ""
":ref:`basic-equations` 에 대한 첫 번째 장에서 연속 동작을 설명하는 방법에 대한 예를 보았습니다. "
"그 장에서 소개된 방정식은 항상 문제를 해결 할 수(applied) 있었고, 그 방정식에 대한 해는 항상 연속적이었습니다. "
"이 장에서는 이산 동작을 설명하기 위해 모델리카의 다양한 방법에 대해 논의했습니다. "
"모델리카의 모든 이산적인 동작의 근본 원인은 이벤트 였습니다."
 
#: ../../source/behavior/discrete/events.rst:16
msgid "Conditional Expressions"
msgstr ""
"조건문(Conditional Expressions)"

#: ../../source/behavior/discrete/events.rst:22
msgid ""
"Events are generated in one of two ways.  First, they can be generated by"
" conditional expressions.  In the first few examples in this chapter, we "
"saw that conditional expressions can trigger events.  If these "
"conditional expressions only involve the variable ``time``, then we call "
"them \"time events\".  The ``time`` variable is a built-in, global "
"variable that is treated as an \"input\" to all models."
msgstr ""
"이벤트는 두 가지 방법 중 하나로 생성됩니다. "
"첫째, 조건식으로 생성할 수 있습니다. "
"이 장의 처음 몇 가지 예제에서 조건식이 이벤트를 트리거할 수 있음을 확인했습니다. "
"이러한 조건식이 ``time`` 변수만 포함하는 경우 "시간 이벤트"라고 합니다. "
"``time`` 변수는 모든 모델에 대한 "입력"으로 처리되는 기본 제공 전역 변수입니다."


#: ../../source/behavior/discrete/events.rst:31
msgid ""
"If events are generated because of conditional expressions that involve "
"solution variables, then we call them \"state events\".  The important "
"distinctions between time events and state events were discussed in the "
":ref:`first <cooling-revisited>` and :ref:`second <bouncing-ball>` "
"sections of this chapter, respectively."
msgstr ""
"해 변수가 포함된 조건식으로 인해 이벤트가 생성되는 경우 이를 "상태 이벤트"라고 합니다. "
"시간 이벤트와 상태 이벤트 간의 중요한 차이점은 각각 이 장의 :ref:`첫번째 <cooling-revisited>` 그리고 :ref:`두번째 <bouncing-ball>` "
"섹션에서 논의되었습니다."


#: ../../source/behavior/discrete/events.rst:37
msgid ""
"Conditional expressions can be created using the relational operators "
"(``>``, ``>=``, ``<``, ``<=``, ``==``) and logical operators (``not``, "
"``and``, ``or``).  As we saw in our discussion of :ref:`no-event`, it is "
"possible to suppress the events generated by these conditional "
"expressions by surrounding them with the ``noEvent`` operator."
msgstr ""
"관계 연산자(``>`` , ``>=`` , ``<`` , ``<=`` , ``==`` ) 및 논리 연산자(``not`` , ``and`` , ``or`` )를 사용하여 조건식을 만들 수 있습니다."
":ref:`no-event` 에 대한 논의에서 보았듯이 이러한 조건식을 ``noEvent`` 연산자로 둘러싸서 이러한 조건식에 의해 "
"생성된 이벤트를 억제할 수 도 있습니다."


#: ../../source/behavior/discrete/events.rst:43
msgid ""
"Frequently, these event generating conditional expressions occur in the "
"context of an ``if`` statement or an ``if`` expression.  But it should "
"also be noted that even a simple variable assignment, *e.g.,*"
msgstr ""
"종종 이러한 이벤트 생성 조건식은 ``if`` 문 또는  ``if``  표현식의 컨텍스트에서 발생합니다. "
"그러나 간단한 변수 할당에 의해서도 가능한데 이에 대해 *예를 들면,* 아래와 같습니다."


#: ../../source/behavior/discrete/events.rst:53
msgid "can trigger an event to be generated."
msgstr ""

#: ../../source/behavior/discrete/events.rst:56
msgid "Piecewise Constructions"
msgstr ""
"구분적 구조(Piecewise Constructions)"

#: ../../source/behavior/discrete/events.rst:58
msgid ""
"There is an important special case when dealing with conditional "
"expressions.  In some cases, it is useful to create an expression that is"
" constructed piecewise.  For example,"
msgstr ""
"조건식을 다룰 때 중요한 특별한 경우가 있습니다."
"구간을 구분하여 구성하는 식을 만드는 것이 유용한 경우가 있는데, 예를 들어 아래와 같습니다,"


#: ../../source/behavior/discrete/events.rst:66
msgid ""
"It is hard for a Modelica compiler to reliably determine that such a "
"function is continuous and has continuous derivatives.  For this reason, "
"Modelica includes the ``smooth`` operator to explicitly express such "
"conditions.  For example, using the ``smooth`` operator as follows:"
msgstr ""
"모델리카 컴파일러가 이러한 함수가 연속적이고 연속 도함수를 갖는다는 것을 확실하게 판단하는 것은 어렵습니다."
"이러한 이유로 모델리카는 연속적이라는 조건을 명시적으로 표현하기 위해 ``smooth`` 연산자를 포함 하고 있습니다. "
"다음과 같이 ``smooth`` 연산자에 대해서 예를 살펴 볼 수 있습니다."


#: ../../source/behavior/discrete/events.rst:76
msgid ""
"indicates that the expression is continuous as is and will remain "
"continuous if differentiated up to 2 times because"
msgstr ""
"식이 연속적이라는 의미이며 두 번까지 미분해도 연속으로 유지됨을 나타냅니다."
k
#: ../../source/behavior/discrete/events.rst:79
msgid ""
"x' & =   \\begin{cases}     0,        & \\text{for } x < 0, \\\\     3 "
"\\, x^2, & \\text{otherwise,}   \\end{cases} \\\\ x'' & =   "
"\\begin{cases}     0,        & \\text{for } x < 0, \\\\     6 \\, x, "
"\\phantom{^2} & \\text{otherwise,}   \\end{cases} \\\\ x''' & =   "
"\\begin{cases}     0,        & \\text{for } x < 0, \\\\     6, "
"\\phantom{6 \\, ^2}& \\text{otherwise.}   \\end{cases}"
msgstr ""

#: ../../source/behavior/discrete/events.rst:97
msgid ""
"Hence, the function, its first and second derivatives are continuous at "
":math:`x=0`, but the third derivative is discontinuous."
msgstr ""
"따라서 함수, 함수의 1차 및 2차 도함수는 :math:`x=0` 에서 연속적이지만 3차 도함수는 불연속입니다."
  


#: ../../source/behavior/discrete/events.rst:100
msgid "Note that the ``smooth`` operator requires an upper bound to be specified."
msgstr ""
"이와 같이 ``smooth`` 연산자를 사용하려면 상한선을 지정해야 한다는 점을 기억해야 합니다."


#: ../../source/behavior/discrete/events.rst:104
msgid "Events and Functions"
msgstr ""
"이벤트 와 함수(Events and Functions)"

#: ../../source/behavior/discrete/events.rst:106
msgid ""
"In addition to being generated by conditional expressions, events can "
"also be generated by certain functions in Modelica."
msgstr ""
"조건식에 의해 생성되는 것 외에도 이벤트는 모델리카의 특정 기능에 의해 생성될 수도 있습니다."

#: ../../source/behavior/discrete/events.rst:110
msgid "Event Generating Functions"
msgstr ""
"이벤트를 생성하는 함수(Event Generating Functions)"

#: ../../source/behavior/discrete/events.rst:112
msgid ""
"The following is a list of functions that generate events wherever the "
"return value has a discontinuity."
msgstr ""
"다음은 반환 값에 불연속성이 있는 경우 이벤트를 생성하는 함수 목록입니다."

#: ../../source/behavior/discrete/events.rst:116
#: ../../source/behavior/discrete/events.rst:137
#: ../../source/behavior/discrete/events.rst:153
#: ../../source/behavior/discrete/events.rst:170
msgid "Function"
msgstr ""
"함수(Function)"

#: ../../source/behavior/discrete/events.rst:116
#: ../../source/behavior/discrete/events.rst:137
#: ../../source/behavior/discrete/events.rst:153
#: ../../source/behavior/discrete/events.rst:170
msgid "Description"
msgstr ""
"설명(Description)"

#: ../../source/behavior/discrete/events.rst:118
msgid "``div(x,y)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:118
msgid "Algebraic quotient with fractional part discarded."
msgstr ""
"소수 부분을 버린 대수적 몫 (Algebraic quotient with fractional part discarded.)"

#: ../../source/behavior/discrete/events.rst:119
msgid "``mod(x,y)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:119
msgid "Modulus of ``x``/``y``"
msgstr ""
"``x``/``y`` 의 계수 (Modulus of ``x``/``y``)"

#: ../../source/behavior/discrete/events.rst:120
msgid "``rem(x,y)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:120
msgid "Remainder from the algebraic quotient"
msgstr ""
"대수적 몫의 나머지 (Remainder from the algebraic quotient)"

#: ../../source/behavior/discrete/events.rst:121
msgid "``ceil(x)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:121
msgid "Smallest integer not less than ``x``"
msgstr ""
"``x`` 보다 작지 않은 가장 작은 정수 (Smallest integer not less than ``x``)"


#: ../../source/behavior/discrete/events.rst:122
msgid "``floor(x)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:122
msgid "Largest integer not greater than ``x`` (returns a ``Real``)"
msgstr ""
"``x`` 보다 크지 않은 가장 큰 정수(``Real`` 반환) (Largest integer not greater than ``x`` (returns a ``Real``))"

#: ../../source/behavior/discrete/events.rst:123
msgid "``integer(x)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:123
msgid "Largest integer not greater than ``x`` (returns an ``Integer``)"
msgstr ""
"``x`` 보다 크지 않은 가장 큰 정수(``정수`` 반환) (Largest integer not greater than ``x`` (returns an ``Integer``))"

#: ../../source/behavior/discrete/events.rst:124
msgid "``initial()``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:124
msgid "``true`` during initialization, otherwise ``false``"
msgstr ""
"초기화 중에는 ``true``, 그렇지 않으면 ``false`` (``true`` during initialization, otherwise ``false``)"

#: ../../source/behavior/discrete/events.rst:125
msgid "``terminal()``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:125
msgid "``true`` at end of simulation, otherwise ``false``"
msgstr ""
"시뮬레이션 종료 시 ``true``, 그렇지 않으면 ``false`` (``true`` at end of simulation, otherwise ``false``)"

#: ../../source/behavior/discrete/events.rst:126
msgid "``sample(t0,dt)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:126
msgid "Generates an event at ``t0`` and every ``dt`` seconds later"
msgstr ""
"``t0`` 에 이벤트를 생성하고 이후 ``dt`` 초마다 (Generates an event at ``t0`` and every ``dt`` seconds later)"

#: ../../source/behavior/discrete/events.rst:127
msgid "``edge(x)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:127
msgid "``true`` only at the instant that ``x`` is ``true``"
msgstr ""
"``x`` 가 참인 순간에만 참 (``true`` only at the instant that ``x`` is ``true``)"

#: ../../source/behavior/discrete/events.rst:128
msgid "``change(x)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:128
msgid "``true`` whenever ``x`` changes value"
msgstr ""
"``x`` 가 값을 변경할 때마다 참 (``true`` whenever ``x`` changes value)"

#: ../../source/behavior/discrete/events.rst:132
msgid "Non-Event Generating Functions"
msgstr ""
"비 이벤트 생성 기능(Non-Event Generating Functions)"

#: ../../source/behavior/discrete/events.rst:134
msgid "The following is a table of functions that do **not** generate events:"
msgstr ""
"다음은 이벤트를 생성하지 **않는** 함수의 표입니다."

#: ../../source/behavior/discrete/events.rst:139
msgid "``abs(x)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:139
msgid "Absolute value of ``x``"
msgstr ""
"``x`` 의 절대값 (Absolute value of ``x``)"

#: ../../source/behavior/discrete/events.rst:140
msgid "``sign(x)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:140
msgid "Sign of ``x`` (-1, 0, or 1)"
msgstr ""
"``x`` 의 부호(-1, 0 또는 1) (Sign of ``x`` (-1, 0, or 1))"

#: ../../source/behavior/discrete/events.rst:141
msgid "``sqrt(x)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:141
msgid "Square root of ``x``"
msgstr ""
"``x`` 의 제곱근 (Square root of ``x``)"

#: ../../source/behavior/discrete/events.rst:142
msgid "``min(x,y)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:142
msgid "Minimum value between ``x`` and ``y``"
msgstr ""
"``x`` 와 ``y`` 사이의 최소값 (Minimum value between ``x`` and ``y``)"

#: ../../source/behavior/discrete/events.rst:143
msgid "``max(x,y)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:143
msgid "Maximum value between ``x`` and ``y``"
msgstr ""
"``x`` 와 ``y`` 사이의 최대값 (Maximum value between ``x`` and ``y``)"

#: ../../source/behavior/discrete/events.rst:147
msgid "Event Related Operators"
msgstr ""
"이벤트 관련 연산자(Event Related Operators)"

#: ../../source/behavior/discrete/events.rst:149
msgid ""
"The following operators provide special information about event "
"generating signals:"
msgstr ""
"다음 연산자는 이벤트 생성 신호에 대한 특수 정보를 제공합니다."

#: ../../source/behavior/discrete/events.rst:155
msgid "``pre(x)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:155
msgid "During an event, holds the value of ``x`` before the event"
msgstr ""
"이벤트 동안, 이벤트 전에 ``x`` 의 값을 보유합니다. (During an event, holds the value of ``x`` before the event)"

#: ../../source/behavior/discrete/events.rst:156
msgid "``previous(x)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:156
msgid "During clock tick, value of ``x`` during previous clock tick"
msgstr ""
"클록 틱 동안, 이전 클록 틱 동안 ``x`` 의 값 (During clock tick, value of ``x`` during previous clock tick)"

#: ../../source/behavior/discrete/events.rst:157
msgid "``hold(x)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:157
msgid "Anytime, value of ``x`` during previous clock tick"
msgstr ""
"언제든지, 이전 클록 틱 동안의 ``x`` 값 (Anytime, value of ``x`` during previous clock tick)"

#: ../../source/behavior/discrete/events.rst:158
msgid "``sample(expr,clock)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:158
msgid "During clock tick, value of ``expr``"
msgstr ""
"클럭 틱 동안 ``expr`` 값 (During clock tick, value of ``expr``)"

#: ../../source/behavior/discrete/events.rst:159
msgid "``noEvent(expr)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:159
msgid "Suppresses events generated by ``expr``"
msgstr ""
"``expr`` 에 의해 생성된 이벤트를 억제합니다. (Suppresses events generated by ``expr``)"

#: ../../source/behavior/discrete/events.rst:160
msgid "``smooth(p,expr)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:160
msgid "Indicates ``expr`` can be safely differentiated ``p`` times."
msgstr ""
"``expr`` 이 ``p`` 번 안전하게 미분될 수 있음을 나타냅니다. (Indicates ``expr`` can be safely differentiated ``p`` times.)_"

#: ../../source/behavior/discrete/events.rst:164
msgid "Clock Related Operators"
msgstr ""
"클럭 관련 연산자(Clock Related Operators)"

#: ../../source/behavior/discrete/events.rst:166
msgid ""
"The following operators are used to create a manipulate clocks (event "
"generators that trigger at regular intervals):"
msgstr ""
"다음 연산자는 클럭(일정한 간격으로 트리거하는 이벤트 생성기)을 조작하는데 사용합니다."

#: ../../source/behavior/discrete/events.rst:172
msgid "``Clock(i,r)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:172
msgid ""
"A clock that fires every :math:`\\frac{i}{r}` seconds where ``i`` and "
"``r`` are both of type ``Integer``"
msgstr ""
"``i`` 와 ``r`` 이 모두 ``Integer`` 자료형인 매 :math:`\frac{i}{r}` 초마다 실행되는 clock (A clock that fires every :math:`\frac{i}{r}` seconds where ``i`` and ``r`` are both of type ``Integer``)"


#: ../../source/behavior/discrete/events.rst:173
msgid "``Clock(dt)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:173
msgid "A clock that fires every :math:`dt` seconds where ``dt`` is a ``Real``"
msgstr ""
"``dt`` 가 ``Real`` 인 매 :math:`dt` 초마다 실행되는 clock (A clock that fires every :math:`dt` seconds where ``dt`` is a ``Real``)"

#: ../../source/behavior/discrete/events.rst:174
msgid "``subSample(u,s)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:174
msgid ""
"A clock that samples ``s`` times slower than the clock used to sample "
"``u`` where ``s`` is an ``Integer``"
msgstr ""
"``s`` 가 ``Integer`` 인 ``u`` 를 샘플링하는 데 사용하는 클럭보다 ``s`` 를 더 느리게 샘플링하는 클럭 (A clock that samples ``s`` times slower than the clock used to sample ``u`` where ``s`` is an ``Integer`` )"

#: ../../source/behavior/discrete/events.rst:175
msgid "``superSample(u,s)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:175
msgid ""
"A clock that samples ``s`` times as fast as the clock used to sample "
"``u`` where ``s`` is an ``Integer``"
msgstr ""
"``s`` 가 ``Integer`` 인 ``u`` 를 샘플링하는 데 사용된 클럭만큼 빠르게 ``s`` 를 샘플링하는 클럭 (A clock that samples ``s`` times as fast as the clock used to sample ``u`` where ``s`` is an ``Integer``)"

#: ../../source/behavior/discrete/events.rst:178
msgid ""
"Note that the ``Clock`` constructor function is overloaded (*i.e.,* can "
"take different arguments).  It is worth reiterating that the synchronous "
"clock features in Modelica are relatively new.  As such, they are not yet"
" supported by all Modelica compilers.  To learn more about these "
"synchronous features and their applications see [Elmqvist]_ and/or the "
"Modelica Specification, version 3.3 or later."
msgstr ""
"``Clock`` 생성자 함수는 오버로드되어 있습니다(*즉,* 다른 인수를 취할 수 있음)."
"모델리카의 동기식 클록 기능은 비교적 새로운 기능이기 때문에, 아직 모든 모델리카 컴파일러에서 지원되지 않습니다. "
"이러한 동기 기능 및 해당 응용 프로그램에 대한 자세한 내용은 [Elmqvist]_ 또는 모델리카 사양 버전 3.3 이상을 참조하십시오."


#~ msgid ""
#~ "It is hard for a Modelica compiler"
#~ " to reliably determine that such a"
#~ " function is continuous or whether it"
#~ " has continuous derivatives.  For this "
#~ "reason, Modelica includes the ``smooth`` "
#~ "operator to explicitly express such "
#~ "conditions.  For example, using the "
#~ "``smooth`` operator as follows:"
#~ msgstr ""

#~ msgid ""
#~ "indicates that the expression is "
#~ "continuous as is and will remain "
#~ "continuous if differentiated up to 2 "
#~ "times.  Of course, in this case "
#~ "the expression is continuous regardless "
#~ "of the number of differentiations.  But"
#~ " the ``smooth`` operator requires an "
#~ "upper bound to be specified."
#~ msgstr ""

#~ msgid "``smooth(expr,p)``"
#~ msgstr ""

#~ msgid ""
#~ "A clock that samples ``s`` times "
#~ "faster than the clock used to "
#~ "sample ``u`` where ``s`` is an "
#~ "``Integer``"
#~ msgstr ""

#~ msgid ""
#~ "\"Fundamentals of Synchronous Control in "
#~ "Modelica\", Hilding Elmqvist, Martin Otter "
#~ "and Sven-Erik Mattsson "
#~ "http://www.ep.liu.se/ecp/076/001/ecp12076001.pdf"
#~ msgstr ""

#~ msgid "events"
#~ msgstr ""

#~ msgid "time events"
#~ msgstr ""

#~ msgid "time"
#~ msgstr ""

#~ msgid "state events"
#~ msgstr ""

