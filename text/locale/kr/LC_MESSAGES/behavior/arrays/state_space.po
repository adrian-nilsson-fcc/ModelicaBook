#
msgid ""
msgstr ""
"Project-Id-Version: Modelica by Example v0.3.6\n"
"Report-Msgid-Bugs-To: mail@modelica.co.kr\n"
"POT-Creation-Date: 2023-01-28 22:37+0000\n"
"PO-Revision-Date: 2023-03-12 22:37+0000\n"
"Last-Translator: Baek Youngjin, mail@modelica.co.kr / Ha HyeonSu, <iloveyou934671@gmail.com>\n"
"Language-Team: modelica.co.kr <mail@modelica.co.k>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"


#: ../../source/behavior/arrays/state_space.rst:4
msgid "State Space"
msgstr ""
"상태 공간(State Space)"

#: ../../source/behavior/arrays/state_space.rst:9
msgid "ABCD Form"
msgstr ""
"ABCD 서식(ABCD Form)"

#: ../../source/behavior/arrays/state_space.rst:14
msgid ""
"Recall from our previous discussion on :ref:`odes` that we can express "
"differential equations in the following form:"
msgstr ""
":ref:`odes` 에서 다음 형식으로 미분 방정식을 표현할 수 있음을 다루었습니다."

#: ../../source/behavior/arrays/state_space.rst:17
msgid ""
"\\dot{\\vec{x}}(t) &= \\vec{f}(\\vec{x}(t), \\vec{u}(t), t) \\\\ "
"\\vec{y}(t) &= \\vec{g}(\\vec{x}(t), \\vec{u}(t), t)"
msgstr ""


#: ../../source/behavior/arrays/state_space.rst:22
msgid ""
"In this form, :math:`x` represents the states in the system, :math:`u` "
"represents any externally specified inputs to the system and :math:`y` "
"represents the outputs of the system (*i.e.,* variables that may not be "
"states, but can ultimately be computed from the values of the states and "
"inputs)."
msgstr ""
"이 형식에서 :math:`x` 는 시스템의 상태를 나타내고,  :math:`u` 는 시스템에 외부적으로 지정된 입력을 나타내고 "
":math:`y` 는 시스템의 출력을 나타냅니다(*즉,* 상태가 아닐 수 있지만 궁극적으로 상태 및 입력 값에서 계산될 수 있는 변수)."

#: ../../source/behavior/arrays/state_space.rst:28
msgid ""
"There is a particularly interesting special case of these equations when "
"the functions :math:`\\vec{f}` and :math:`\\vec{g}` depend linearly on "
":math:`\\vec{x}` and :math:`\\vec{u}`.  In this case, the equations can "
"be rewritten as:"
msgstr ""
"함수 :math:`\vec{f}` 및 :math:`\vec{g}` 가 :math:`\vec{x}` 및 :math:`\vec{u}`"
"에 선형적으로 의존할 때 이러한 방정식은 특별합니다."


#: ../../source/behavior/arrays/state_space.rst:33
msgid ""
"\\dot{\\vec{x}}(t) &= A(t) \\vec{x}(t) + B(t) \\vec{u}(t) \\\\ "
"\\vec{y}(t) &= C(t) \\vec{x}(t) + D(t) \\vec{u}(t)"
msgstr ""

#: ../../source/behavior/arrays/state_space.rst:38
msgid ""
"The matrices in this problem are the so-called \"ABCD\" matrices.  This "
"ABCD form is useful because there are several interesting calculations "
"that can be performed once a system is in this form.  For example, using "
"the :math:`A` matrix, we can compute the natural frequencies of the "
"system.  Using various combinations of these matrices, we can determine "
"several very important properties related to control of the underlying "
"system (*e.g.,* observability and controllability)."
msgstr ""
"이 문제의 행렬은 소위 "ABCD" 행렬 이라고 부르며, 시스템이 이 형식인 경우 수행할 수 있는 몇 가지 흥미로운 계산이 있기 때문에 유용합니다. "
"예를 들어 :math:`A` 행렬을 사용하여 시스템의 고유 주파수를 계산할 수 있습니다."
"이러한 매트릭스의 다양한 조합을 사용하여 기본 시스템 제어와 관련된 몇 가지 매우 중요한 속성"
"(*예:* 관찰 가능성 및 제어 가능성)을 결정할 수 있습니다."


#: ../../source/behavior/arrays/state_space.rst:47
msgid ""
"Note that this ABCD form allows these matrices to vary with time. There "
"is a slightly more specialized form that, in addition to being linear, is"
" also time-invariant:"
msgstr ""
"위의 ABCD 형식을 사용하면 행렬이 시간에 따라 변화하는데, 아래의 경우 처럼 시불변이면서 선형인 약간 더 특수화된 형식이 있습니다."


#: ../../source/behavior/arrays/state_space.rst:51
msgid ""
"\\dot{\\vec{x}}(t) &= A \\vec{x}(t) + B \\vec{u}(t) \\\\ \\vec{y}(t) &= C"
" \\vec{x}(t) + D \\vec{u}(t)"
msgstr ""

#: ../../source/behavior/arrays/state_space.rst:58
msgid ""
"This form is often called the \"LTI\" form.  The LTI form is important "
"because, in addition to having the same special properties as the ABCD "
"form, the LTI form can be used as a very simple form of \"model "
"exchange\".  Historically, when someone derived the behavior equations "
"for a given system (either by hand or using some modeling tool), one way "
"they could import those equations into other tools was to put them in the"
" LTI form.  This means that the model could be exchanged, shared or "
"published as a series of matrices with either numbers or expressions in "
"them.  Today, technologies like Modelica and `FMI <http://fmi-"
"standard.org>`_ provide much better options for model exchange."
msgstr ""
"이러한 양식을 "LTI" 양식이라고 부르기도 합니다. "
"LTI 형식은 ABCD 형식과 동일한 특수 속성을 갖는 것 외에도 "모델 교환" 형식으로 매우 간단하게 사용할수 있기 때문에 중요합니다. "
"역사적으로 누군가가 주어진 시스템에 대한 동작 방정식을 도출할 때(손으로 또는 일부 모델링 도구를 사용하여) 해당 방정식을 "
"다른 시뮬레이션 소프트웨어로 가져올 수 있는 한 가지 방법은 방정식을 LTI 형식으로 넣는 것이었습니다. "
"이는 모델이 숫자 또는 표현식이 포함된 일련의 행렬로 교환, 공유 또는 게시될 수 있음을 의미합니다."
"물론, 이제는 모델리카 및 `FMI <http://fmi-standard.org>`_ 와 같은 기술은 모델 교환을 위한 훨씬 더 나은 옵션을 제공하긴 합니다."


#: ../../source/behavior/arrays/state_space.rst:71
msgid "LTI Models"
msgstr ""
"LTI 모델(LTI Models)"

#: ../../source/behavior/arrays/state_space.rst:73
msgid ""
"If someone gave us a model in LTI form, how would we express that in "
"Modelica?  Here is one way we might choose to do it:"
msgstr ""
"누군가 LTI 형식으로 모델을 제공했다면 모델리카에서 어떻게 표현할까요? "
"이때 선택할 수 있는 한 가지 방법을 살펴 보겠습니다."


#: ../../source/behavior/arrays/state_space.rst:80
msgid ""
"The first step in this model is to declare the parameters ``nx``, ``nu`` "
"and ``ny``.  These represent the number of states, inputs and outputs, "
"respectively.  Next, we define the matrices ``A``, ``B``, ``C`` and "
"``D``.  Because we are creating a model for a linear, time-invariant "
"representation all of these matrices can be parameters. We know that "
"``A``, ``B``, ``C`` and ``D`` are arrays because their declarations "
"followed by ``[`` and ``]``.  We know they are matrices because within "
"the ``[]``\\ s there are two dimensions given.  Finally, we see "
"declarations for ``x0``, ``x``, ``u`` and ``y``.  These are also arrays."
"  But in this case, they are vectors, since they each have only a single "
"dimension."
msgstr ""
"이 모델의 첫 번째 단계는 ``nx`` , ``nu`` 및 ``ny`` 파라미터를 선언하는 것이며, 이들은 각각 상태, 입력 및 출력의 수를 나타냅니다. "
"다음으로 행렬 ``A`` , ``B`` , ``C`` 및 ``D`` 를 정의합니다. "
"선형의 시불변 표현을 위한 모델을 만들고 있기 때문에 이러한 모든 행렬이 파라미터가 될 수 있습니다. "
"``A`` , ``B`` , ``C`` 및 ``D`` 는 선언 뒤에 ``[`` 및  ``]`` 가 있기 때문에 배열이고, ``[]`` 들 안에 두 개의 차원이 있기 때문에  그것들이 행렬이라는 것을 압니다."
"마지막으로 ``x0`` , ``x`` , ``u`` 및 ``y`` 에 대한 선언을 볼 수 있으며, 이것들도 배열입니다. "
"그러나 이 경우에는 각각 단일 차원만 가지므로 벡터입니다."


#: ../../source/behavior/arrays/state_space.rst:92
msgid ""
"Another thing to note about this model is that all parameters have been "
"given default values.  For ``nx``, ``nu`` and ``ny``, the assumption is "
"that the number of states, inputs and outputs is zero by default.  For "
"the matrices, we assume that they are filled with zeros by default.  "
"Similarly, for initial conditions we assume that all states start the "
"simulation with a value of zero unless otherwise specified.  We shall see"
" shortly how these assumptions make it possible for us to write very "
"simple models by simply overriding the values for these parameters."
msgstr ""
"이 모델에 대해 주목해야 할 또 다른 사항은 모든 파라미터에 기본값이 주어졌다는 것입니다. "
"``nx``  , ``nu`` 및 ``ny`` 의 경우 상태, 입력 및 출력의 수가 기본적으로 0이라고 가정하며, 행렬의 경우 또한 기본적으로 0으로 채워져 있다고 가정합니다. "
"마찬가지로, 초기 조건의 경우 달리 지정하지 않는 한 모든 상태가 0 값으로 시뮬레이션을 시작한다고 가정합니다. "
"이러한 가정을 통해 이러한 파라미터의 값을 단순히 재정의함으로써 매우 간단한 모델을 작성할 수 있는 방법을 곧 설명 하겠습니다."


#: ../../source/behavior/arrays/state_space.rst:103
msgid "Vector Equations"
msgstr ""
"벡터 방정식(Vector Equations)"

#: ../../source/behavior/arrays/state_space.rst:105
msgid ""
"The rest of the model should look pretty familiar by now.  One thing that"
" is important to point out is the fact that the equations in this model "
"are all **vector** equations.  An equation in Modelica can involve "
"scalars or arrays.  The only requirement is that both side of the "
"equation have the same number of dimensions and the same size for each "
"dimension.  So in the case of the ``LTI`` model, we have the following "
"initial equation:"
msgstr ""
"이제는, 모델의 나머지 부분의 경우는 꽤 익숙해 보일 것입니다."
"지적해야 할 중요한 한 가지는 이 모델의 방정식이 모두 **벡터** 방정식이라는 사실입니다."
"모델리카의 방정식에는 스칼라 또는 배열이 포함될 수 있는데, 이때의 유일한 요구 사항은 방정식의 양쪽 측면이 동일한 차원 수와 각 차원에 대해 동일한 크기를 가져야 한다는 것입니다."
"따라서 ``LTI`` 모델의 경우 다음과 같이  초기 방정식을 선언합니다."


#: ../../source/behavior/arrays/state_space.rst:117
msgid ""
"This equation is a vector equation that expresses the fact that each "
"element in ``x`` has the corresponding value in ``x0`` at the start of a "
"simulation.  In practice, what happens is that each element in these "
"vectors is automatically expanded into a series of scalar equations."
msgstr ""
"이 방정식은 시뮬레이션 시작 시 ``x`` 의 각 요소가 ``x0`` 값을 갖는다는 사실을 표현하는 벡터 방정식입니다."
"실제로는 일련의 스칼라 값을 바탕으로 각 요소가 벡터 방정식으로 자동 확장됩니다."


#: ../../source/behavior/arrays/state_space.rst:122
msgid ""
"Another thing that helps keep these equations readable is that Modelica "
"has some special rules regarding :ref:`vectorization` of functions.  In a"
" nutshell, these rules say that if you have a function that works with "
"scalars, you can automatically use it with vectors as well.  If you do, "
"Modelica will automatically apply the function to each element in the "
"vector.  So, for example, the expression ``der(x)`` in the ``LTI`` model "
"is a vector where each element in the vector represents the derivative of"
" the respective element of ``x``."
msgstr ""
"모델리카에 함수의 `벡터화` 와 관련된 몇 가지 특별한 규칙으로 인해 방정식을 바로 읽도록 표현할 수 있습니다. "
"간단히 말해서 이러한 규칙은 스칼라와 함께 작동하는 함수가 있는 경우에도 특별한 변경 없이 벡터와 함께 사용할 수 있습니다."
"모델리카가 자동으로 벡터의 각 요소에 함수를 적용하기 때문 입니다."
"예를 들어, ``LTI`` 모델의 ``der(x)`` 표현은 벡터의 각 요소가 ``x`` 의 각 요소의 도함수를 나타내는 벡터로 사용합니다."


#: ../../source/behavior/arrays/state_space.rst:131
msgid ""
"Finally, many of the typical algebraic operators like ``+``, ``-`` and "
"``*`` have special meanings when applied to vectors and matrices. These "
"definitions are designed so that they correspond with conventional "
"mathematical notation.  So in the ``LTI`` model, the expression ``A*x`` "
"corresponds to a matrix-vector product."
msgstr ""
"마지막으로 ``+``, ``-`` 및 ``*`` 와 같은 많은 일반적인 대수 연산자는 벡터 및 행렬에 적용될 때 특별한 의미를 갖는데, 이에 대한 정의는 기존의 수학적 표기법과 일치하도록 설계되었습니다. "
"따라서 ``LTI`` 모델에서 ``A*x`` 라는 표현은 행렬-벡터 곱에 해당합니다."


#: ../../source/behavior/arrays/state_space.rst:138
msgid "LTI Examples"
msgstr ""
"LTI 예제(LTI Examples)"

#: ../../source/behavior/arrays/state_space.rst:140
msgid ""
"With all this in mind, let's revisit several of our previous examples to "
"see how they can be represented in LTI form using our ``LTI`` model.  "
"Note that we will again use inheritance (via the ``extends`` keyword) to "
"reuse the code in the ``LTI`` model."
msgstr ""
"이 모든 것을 염두에 두고, 이전 예제를 다시 ``LTI`` 모델을 사용하여 어떻게 표현할 수 있는지 살펴보겠습니다. "
"``LTI`` 모델에서 코드를 재사용하기 위해 상속(``extends`` 키워드를 통해)을 사용할 것입니다."



#: ../../source/behavior/arrays/state_space.rst:145
msgid ""
"Let's start with the :ref:`first-order` we presented earlier.  Using the "
"``LTI`` model, we can write this model as:"
msgstr ""
"앞에서 제시한 :ref:`first-order` 부터 시작해보면, ``LTI`` 모델을 사용하여 다음과 같이 작성할 수 있습니다."

#: ../../source/behavior/arrays/state_space.rst:152
msgid ""
"When we extend from ``LTI``, we only need to specify the parameter values"
" that are different from the default values.  In this case, we specify "
"that there is one state and one input.  Then we specify `A` and `B` as "
"1x1 matrices.  Finally, since we have an input, we need to provide an "
"equation for it.  The input can, in general, be time-varying so we don't "
"represent it as a parameter, but rather with an equation.  Note that in "
"the equation:"
msgstr ""
"``LTI`` 에서 확장할 때 기본값과 다른 파라미터 값만 지정하면 됩니다. "
"이 경우 하나의 상태와 하나의 입력이 있음을 정의하고, `A` 와 `B` 를 1x1 행렬로 지정합니다. "
"마지막으로 입력이 있으므로 이에 대한 방정식을 제공해야 하는데, 입력은 일반적으로 시간에 따라 변할 수 있으므로 파라미터로 표시하지 않고 방정식으로 표시합니다."


#: ../../source/behavior/arrays/state_space.rst:164
msgid ""
"the expression ``{1}`` is a vector literal.  This means that we are "
"building a vector as a list of its components.  In this case, the vector "
"has only one component, ``1``.  But we can build longer vectors using a "
"comma separated list of expressions, *e.g.,*"
msgstr ""
"``{1}`` 표현식은 벡터 리터럴입니다. "
"이는 벡터를 구성 요소 목록으로 작성하고 있음을 의미하며, 이 경우 벡터에는 하나의 구성 요소인 ``1`` 만 있습니다. "
"그러나 *예제* 와 같이 쉼표로 구분된 표현식 목록을 사용하여 더 긴 벡터를 만들 수 있습니다."


#: ../../source/behavior/arrays/state_space.rst:175
msgid ""
"It is worth noting that, in addition to setting parameter values, we also"
" can include equations in the ``extends`` statement.  So, we could have "
"avoided the ``equation`` section altogether and written the model more "
"compactly as:"
msgstr ""
"파라미터 값을 설정하는 것 외에도 ``extends`` 문에 방정식을 포함할 수 있다는 점은 주목할 가치가 있습니다. "
"따라서  ``equation`` 섹션을 모두 피하고 다음과 같이 모델을 더 간결하게 작성할 수 있었습니다."


#: ../../source/behavior/arrays/state_space.rst:184
msgid ""
"In general, including the ``equation`` section makes the code a bit more "
"readable for others.  But there are some circumstances where it is more "
"convenient to include the equation as a modification in the ``extends`` "
"statement."
msgstr ""
"일반적으로 ``equation`` 섹션을 포함하면 다른 사람들이 코드를 좀 더 읽기 쉽게 만들 수 있습니다. "
"그러나 ``extends`` 문에 방정식을 수정하도록 포함하는 것이 더 편리한 경우가 있습니다."

#: ../../source/behavior/arrays/state_space.rst:189
msgid ""
"Now let's turn our attention to the :ref:`cooling <getting-physical>` we "
"also discussed earlier.  In LTI form, we could have written the model as:"
msgstr ""
"다음으로, 앞에서 논의한 :ref:`cooling <getting-physical>` 에 대해 살펴보겠습니다. "
"LTI 형식으로 모델을 다음과 같이 작성할 수 있습니다."


#: ../../source/behavior/arrays/state_space.rst:197
msgid ""
"This model is very similar to the previous one.  However, in this case, "
"instead of putting numbers into our matrices, we've put expressions "
"involving other parameters like ``m``, ``c_p`` and so on.  In this way, "
"if those physical parameters are changed, the values for ``A`` and ``B`` "
"will change accordingly."
msgstr ""
"이 모델은 이전 모델과 매우 유사합니다만, 행렬에 숫자를 넣는 대신 ``m``, ``c_p`` 등과 같은 다른 파라미터를 포함하는 표현식을 넣었습니다."
"이와 같이 표현하면, 물리적 파라미터가 변경되면 ``A`` 및 ``B`` 값이 그에 따라 변경됩니다."



#: ../../source/behavior/arrays/state_space.rst:203
msgid ""
"We can take a similar approach in reformulating our previous "
":ref:`mechanical example <mech-example>` into LTI form:"
msgstr ""
"이전의 :ref:`mechanical example <mech-example>` 을 LTI 형식으로 재구성할 때 유사한 접근 방식을 취할 수 있습니다."

#: ../../source/behavior/arrays/state_space.rst:210
msgid ""
"Again, we compute ``A`` from physical parameters.  One thing to note "
"about this example is the construction of ``A``.  Mathematically, the "
":math:`A` matrix is defined as:"
msgstr ""
"다시 한 번, 앞서 보인 예제와 동일하게 물리적 파라미터를 이용해서 ``A`` 를 계산하는데, 이 예제에서 주목해야 할 한 가지는 ``A`` 의 구조입니다. "
"수학적으로 :math:`A` 행렬은 다음과 같이 정의합니다."


#: ../../source/behavior/arrays/state_space.rst:214
msgid ""
"A &= \\left| \\begin{array}{cccc} 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1 \\\\ "
"-\\frac{k_1}{J_1} & \\frac{k_1}{J_1} & -\\frac{d_1}{J_1} & "
"\\frac{d_1}{J_1} \\\\ \\frac{k_1}{J_2} & "
"-\\frac{k_1}{J_2}-\\frac{k_2}{J_2} & \\frac{d_1}{J_2} & "
"-\\frac{d_1}{J_2}-\\frac{d_2}{J_2} \\\\ \\end{array} \\right|"
msgstr ""

#: ../../source/behavior/arrays/state_space.rst:227
msgid ""
"One thing we can note about this construction of :math:`A` is that the "
"first two rows might be easier to express as a matrix of zeros and an "
"identity matrix.  In other words, it might be simpler to construct the "
"matrix as a set of sub-matrices, *i.e.,*"
msgstr ""
"이 :math:`A` 구성에 대해 주목할 수 있는 한 가지는, 처음 두 행이 0의 행렬과 항등 행렬로 표현하는 것이 더 쉬울 수 있다는 것입니다. "
"즉, 전체 행렬을 아래와 같이 하위 행렬의 집합으로 구성하는 것이 더 간단할 수 있습니다. "


#: ../../source/behavior/arrays/state_space.rst:232
msgid ""
"A &= \\left| \\begin{array}{cc}   \\left|   \\begin{array}{cc}   0 & 0 "
"\\\\   0 & 0   \\end{array}   \\right|   ~   \\left|   \\begin{array}{cc}"
"   1 & 0 \\\\   0 & 1   \\end{array}   \\right| \\\\   \\left|   "
"\\begin{array}{cc}   -\\frac{k_1}{J_1} & \\frac{k_1}{J_1} \\\\   "
"\\frac{k_1}{J_2} & -\\frac{k_1}{J_2}-\\frac{k_2}{J_2}   \\end{array}   "
"\\right|   \\left|   \\begin{array}{cc}   -\\frac{d_1}{J_1} & "
"\\frac{d_1}{J_1} \\\\   \\frac{d_1}{J_2} & "
"-\\frac{d_1}{J_2}-\\frac{d_2}{J_2}   \\end{array}   \\right| \\end{array}"
" \\right|"
msgstr ""

#: ../../source/behavior/arrays/state_space.rst:264
msgid ""
"In Modelica, we can construct our ``A`` matrix from sub-matrices in this "
"way:"
msgstr ""
"모델리카에서는 다음과 같은 방법으로 ``A`` 행렬에 대해 하위 행렬을 이용해서 구성할 수 있습니다."

#: ../../source/behavior/arrays/state_space.rst:271
msgid ""
"In the section above we do not include a representation of the Lotka-"
"Volterra equations in LTI form.  This is because the Lotka-Volterra "
"equations, while being time-invariant, are not linear. It is worth "
"pointing out that Modelica does not directly enforce either of these "
"properties when using the ``LTI`` model.  So it is possible to represent "
"non-linear or time-variant models using this approach.  But it would be "
"confusing since the term LTI implies that the equations are both linear "
"and time-invariant."
msgstr ""
"위 섹션에서  Lotka-Volterra 방정식 표현을 LTI 형식으로 바꾸는 내용은 포함하지 않았는데, 이는 Lotka-Volterra 방정식이 시불변이지만 선형이 아니기 때문입니다."
"모델리카에서는 ``LTI`` 모델을 사용할 때와 같은 속성(시불변, 선형) 중 어느 것도 직접 관여하지 않기 때문에 비선형 또는 시변 모델을 나타낼 수 있었습니다. "
"그러나, LTI 형태는 선형이고 시불변이라는 것을 의미하기 때문에 혼란스럽게 느껴질 수 있습니다."


#: ../../source/behavior/arrays/state_space.rst:281
msgid "Using Components"
msgstr ""
"구성요소 사용(Using Components)"

#: ../../source/behavior/arrays/state_space.rst:283
msgid ""
"In all of these examples so far, we've used inheritance (via ``extends``)"
" to reuse the equations from the ``LTI`` model.  In general, there is a "
"**much better** way to reuse these equations which is to **treat them as "
"sub-components**.  To see how this is done, we will recast our previous "
":ref:`electrical examples <elec-example>` in LTI form.  But this time, "
"we'll create a named instance of the ``LTI`` model:"
msgstr ""
"지금까지의 모든 예제에서  ``extends`` 를 통해 상속으로 ``LTI`` 모델의 방정식을 재사용했습니다. "
"그러나, 일반적으로 방정식을 **하위 구성 요소로 취급** 하는 방식이 방정식을 재사용 하는 **훨씬 더 좋은** 방법입니다."
"어떻게 이 방법을 사용하는지 확인하기 위해, 이전 :ref:`electrical examples <elec-example>` 을 LTI 형식으로 재구성해보겠습니다."
"이번에는 ``LTI`` 모델을 이름이 정해진 인스턴스를 만드는 방식으로 구현할 것입니다."


#: ../../source/behavior/arrays/state_space.rst:295
msgid ""
"Note that this time we do not use ``extends`` or inheritance of any kind."
"  Instead, we actually declare a variable called ``rlc_comp`` that is of "
"type ``LTI``.  Once we have finished covering all the basics of how to "
"describe different kinds of behavior in Modelica, we'll turn our "
"attention to how to organize all these equations into reusable "
":ref:`components`.  But for now, this is just a \"sneak peek\" of (big) "
"things to come."
msgstr ""
"``LTI`` 타입인 ``rlc_comp`` 라는 변수를 선언하고, ``extends`` 또는 어떤 종류의 상속도 사용하지 않았습니다. "
"다양한 동작을 구현하는 모델리카의 기본 방법을 모두 다룬 후에 전체 방정식을 재사용 가능한 구성 요소로 표현하는 방법을 다루겠습니다. "
"지금 보이는 방식은 나중에 다룰 큰 그림에 대한 "미리 보기" 수준 입니다."


#: ../../source/behavior/arrays/state_space.rst:303
msgid ""
"What we see in this `RLC` example is that we now have a variable called "
"``rlc_comp`` and this component, in turn, has all the parameters and "
"variables of the ``LTI`` model inside it.  So, for example, we see that "
"our equation to specify the input, ``u``, is written as:"
msgstr ""
"위 예제에서 볼 수 있는 것은, ``rlc_comp`` 라는 변수가 있고 이 구성 요소에는 ``LTI`` 모델의 모든 파라미터와 "
"변수가 내부에 있다는 것입니다. "
"예를 들어, 입력 ``u`` 를 지정하는 등식은 다음과 같이 작성 합니다."


#: ../../source/behavior/arrays/state_space.rst:313
msgid ""
"Note that this equation means that we are providing an equation for the "
"variable ``u`` that is **inside** the variable ``rlc_comp``.  As we will "
"see later, we can use hierarchy to manage a considerable amount of "
"complexity that arises from complex system descriptions. The use of the "
"``.`` operation here is how we can reference variables that are organized"
" in this hierarchical manner.  Again, this will be discussed thoroughly "
"when we introduce :ref:`components`."
msgstr ""
"변수 ``rlc_comp`` **내부** 에 있는 변수 ``u`` 에 대한 방정식을 위의 표현을 통해 제공하고 있습니다."
"나중에 살펴보겠지만 복잡한 시스템을 표현할때 생기는 상당한 양의 복잡성을 관리하기 위해 계층 구조를 사용할 수 있는데, ``.`` 연산을 사용하면 계층 구조의 변수를 참조할 수 있습니다."
"다시 말하지만, 이것은 뒤에서 컴포넌트를 소개할 때 철저히 논의하겠습니다."


#~ msgid ""
#~ "In this form, :math:`x` represents the"
#~ " states in the system, :math:`u` "
#~ "represents any externally specified inputs "
#~ "to the system and :math:`y` represents"
#~ " the outputs of the system (*i.e.,*"
#~ " variables that are not states, but"
#~ " can ultimately be computed from the"
#~ " values of the states and inputs)."
#~ msgstr ""

#~ msgid ""
#~ "Note that this time we do not "
#~ "use ``extends`` or inheritance of any"
#~ " kind.  Instead, we actually declare "
#~ "a variable called ``rlc_comp`` that is"
#~ " of type ``LTI``.  Once we have "
#~ "finished covering all the basics of "
#~ "how to describe different kinds of "
#~ "behavior in Modelica, we'll turn our "
#~ "attention to how to organize all "
#~ "these equations into reusable "
#~ ":ref:`components`.  But for now, this is"
#~ " just a \"sneak peak\" of (big) "
#~ "things to come."
#~ msgstr ""

#~ msgid "ABCD"
#~ msgstr ""

#~ msgid "FMI"
#~ msgstr ""

